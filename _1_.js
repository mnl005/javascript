// 프로그래밍 언어 = 구문 + 의미
// Ajax : 브라우저가 비동기 방식으로 데이터를 교환해 데이터를 주고받는 기능
// jQuery : DOM 조작이나 Ajax 요청을 간단한 코드로 처리하는 자바스크립트 라이브러리
// node.js : 구글 v8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
// 자바스크립트 특징 : 비동기 지원, 단일 스레드, 이벤트 루프
// 브라우저의 목적 : 브라우저,HTML,css,자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링 하는것이 주 목적
// Node.js의 목적 : 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주 목적이다,
// 브라우저와 Node.js의 공통점 : 자바스크립트 코어인 ECMAScript를 실행할 수 있지만, Node.js와 ECMAScript 이외에 추가로 제공되는 기능은 호환되지 않는다
// 브라우저와 Node.js의 차이점 : 브라우저는 HTML 요소 조작하는 DOM API를 제공, Node.js는 브라우저 외부 환경에서 DOM 요소 조작 필요 없어서 DOM API 미제공
// 자바스크립트 실행 방법 : 브라우저에서 실행, 코드 에디터에서 실행(node.js 환경)
// 자바스크립트는 개발자가 별도의 컴파일 수행하지 않는 인터프리터 언어로 코드가 한 줄씩 순차적으로 실행
// ... 인터프리터 언어는 코드 실행 단계에서 문 단위로 코드를 바이트 코드로 변환해 실행
// 자바스크립트는 메모리를 개발자가 직접 관리하지 않음으로 언매니지드 언어이다
// 자바스크립트 표준 사양 : ECMA-262, 이 사양을 기반으로 브라우저 엔진을 개발
// npm : 자바스크립트 패키지 매니저


// 변수 ----------------------------------------------------------------------------------------
// 10 + 20 ----> 연산을 위해 리터럴(10.20.+),연산자(+),표현식(10 + 20),의미해석(파싱)
// 연산을 수행시 좌우변의 숫자값(피연산자) 를 메모리셀에 저장 또는 읽어온다
// 컴퓨터는 모든 데이터를 2진수로 저장
// 계산 결과도 메모리에 저장되나 결과값이 저장된 메모리 주소로 직접 접근할 경우 오류 발생 가능성 높다
// 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다

// 변수 : 메모리 주소가 매핑될 식별자
// 할당 : 변수에 값이 저장된 메모리 주소를 매핑
// 참조 : 변수에 저장된 값을 읽어 들이는 것
// 변수이름 : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
// 식별자(변수이름) : 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 식별자는 값이 아닌 값이 저장된 메모리 주소를 기억
// 식별자 용어정리 : 변수,함수,클래스 등의 식별자는 네이밍 규칙을 준수해야 하고, 선언에 의해 자바스크립트 엔진에 식별자를 알린다
// 식별자 네이밍 규칙 : 특수문자와 식별자 제외한 문자,숫자,_,$ 포함 가능하나 숫자로 시작하는 식별자 불가
// 순서 : 소스코드 실행 전 소스코드 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수선언문,함수선언문) 등을 소스코드에서 찾아 먼저 실행
// ... 소스코드 평가 과정 이후 소스코드 한 줄씩 실행
// ... 자바스크립트는 변수 선언의 위치와 상관없이 다른 코드보다 먼저 실행

// 변수 선언 : 값저장 위한 메모리공간 확보, 확보된 공간의 메모리 주소를 연결해서 값을 저장할 준비
// var 키워드로 선언한 변수는 undefined 값이 암묵적으로 할당되어 초기화
// .. 초기화는  변수가 선언된 이후 최초로 값을 할당하는 것
// var 는 함수레벨스코프로 의도치 않은 전역변수 선언 발생 가능성 높다
// 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징
// ... 단 값의 할당은 런타임 시점에 실행
// 변수 선언과 값의 할당을 단축 표현해도 두개의 문으로 나뉘어 각각 실행
// 선언되지 않은 식별자에 접근시 엔진에 등록된 식별자를 찾을 수 없음으로 참조 에러 발생
// 자바스크립틍서 선언하는 모든 식별자는 기본적으로 호이스팅

console.log("v1 : ", v1); // undefined
var v1;


// 미선언 식별자에 접근시 참조에러 발생
try {
    console.log(qqq);
} catch (e) {
    console.log(e.message); // ReferenceError 에러
}

// 변수와 함수 선언은 런타임 이전에 실행되어 에러 미발생(호이스팅)
console.log(eee); // undefined
var eee;

// 런타임 전 변수 선언 이후, 런타임 이후 변수에 값이 할당
console.log("v2-1 : ", v2); // undefined(메모리에서 값을 참조)
var v2;
v2 = 0; // 새로운 메모리 공간을 확보하고 값을 저장
console.log("v2-2 : ", v2); // 0

// 값의 재할당 : 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
// 재할당 시 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90 을 저장
// 남은 공간은 가비지 콜렉터에 의해 메모리에서 자동 해제, 해제 시점 예측 불가 -> 메모리 누수 방지
var v3 = 10;
v3 = 20;
console.log("v3 : ", v3); // 20

// 변수 명명 규칙
var firstName; // camelCase
var first_name; // snake_case
var FirstName; // PascalCase

// const : 재할당 금지된 변수 선언

// 표현식과 문 ----------------------------------------------------------------------------------------
// 메모리에 값 저장시 이진수로 저장되며 저장된 값은 데이터 타입에 따라 다르게 해석 가능
// 값 : 식(표현식)이 평가되어 생성된 결과
// 표현식 : 값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다
// 표현식의 구성 : 리터럴, 식별자, 연산자, 함수호출 등의 조합
// 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법 ex) 숫자 리터럴인 3
// 표현식 1 + 2 = 3 에서 1+2 와 3 은 동치이다
// 변수 선언문은 값으로 평가 될 수 없음으로 표현식이 아니다
// 문(명령문) : 프로그램을 구성하는 최소 실행 단위, 문의 집합 = 프로그램, 문을 순서에 맞게 나열하는 행위 = 프로그래밍
// 문은 표현식인 문과 표현식이 아닌 문 두가지 존재, 변수에 할당 가능하여 값으로 평가 가능하면 표현식인 문 이다
// 문은 토큰으로 구성
// 토큰 : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소(키워드,식별자,연산자,리터럴,세미콜론,마침표)
// 세미콜론 : 문의 종류, 단 코드 블록 자체 종결성 가지기만 중첩된 경우 결과가 다를 수 있어 붙이는것을 권장

let qwer1, qwer2 = {}, qwer3 = [], qwer4 = function () {
};
// 리터럴 표현식
10
'hello'
// 식별자 표현식
qwer1
qwer2.name
qwer3[0]
// 연산자 표현식
10 + 20
qwer1 = 10
// 함수/메서드 호출 표현식
qwer4()


// 리터럴 종류
let v4 = 100; // 정수
let v5 = 10.5; // 부동소수점
let v6 = 0b01000001; // 2진수
let v7 = 0o101; // 8진수
let v8 = 0x41; // 16진수
let v9 = "qwer"; //  문자열
let v10 = true; // 불리언
let v11 = null;
let v12 = undefined;
let v13 = {a: 10, b: 20}; // 객체
let v14 = [1, 2, 3];
const v15 = () => console.log("function"); // 함수
let v16 = `/[A-Z]+/g`; // 정규 표현식


// 변수 선언문
let v17;
// 할당문
v17 = 0;

// 함수 선언문
function fun1() {
    console.log("fun1");
}

// 조건문
if (true) {
}
// 반복문
for (let i = 0; i < 2; i++) {
}

let v18;
// 1,2,1+2,x=1+2 모두 표현식이다
// x=1+2 는 표현식이면서 완전한 문, 할당문이면서 표현식인 문
v18 = 1 + 2;
// 표현식이 아닌 문은 값처럼 사용 불가 ex) var vv1 = var vv2
// 표현식인 문은 값처럼 사용 가능
let v19;
let x;
v19 = x = 10;
console.log("v19 : ", v19);

// 데이터 타입 ----------------------------------------------------------------------------------------
// 지바스크립트는 값의 종류에 따라 확보해야 할 메모리 공간 크기가 다르다
// 자바스크립트는 동적 타입 언어이다 즉, 변수 선언 이후 값을 할당시 다른 타입을 할당 가능하다, 값을 할당하는 시점에 변수의 타입이 동적으로 변경(동적 타이핑)
// 메모리에 값 저장하는 과정 : 확보할 메모리 공간 크기 결정(타입으로 결정) -> 확보된 메모리에 숫자 값 100을 2진수로 저장
// 메모리의 값을 참조하는 과정 : 식별자 통해 값이 저장된 메모리 공간의 주소를 찾는다 -> 선두 메모리 공간 찾아 나머지 메모리 셀의 바이트 수를 확인 -> 값을 데이터 타입 따라 다르게 해석
// 원시 타입 : Number, String, Boolean, undefined, null, symbol(value)
// 객체 타입 : 객체, 함수, 배열 등

// Number : 자바스크립트는 하나의 숫자 타입만 존재, 모든 수를 실수로 처리, 값을 참조시 10 진수로 해석,배정밀도 64비트 부동소수점 형식의 2진수로 저장
console.log(1 === 1.0); // true
// 숫자 타입의 특별한 값
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "string"); // NaN

// String : 문자열은 0개 이상의 16비트 유니코드(UTF-16) 문자의 집합
let vv1;
vv1 = "문자열";
vv1 = '문자열';
vv1 = `백틱`;
// 탬플릿 리터럴
console.log(`
    \0 \b \f \n \r \t \v \u0041 \' \" \\ ${1 + 2}
    `); // Null, 백스페이스, 폼피드, 다음행, 커서처음으로, 수평탭, 수직탭, 유니코드, 작은따옴표, 큰타옴표, 백슬래시, 표현식 삽입
// 문자열 연결 - +연산자는 피 연산자중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작, 이외의 경우는 덧셈 연산자
console.log("a" + "b");

// Boolean : 논리적 참, 거짓을 나타낸다, true or false
// undefiend : undefined 값은 undefined 값이 유일, 변수 선언시 암묵적으로 undefined로 초기화
// null : null 타입의 값은 null이 유일, 변수에 값이 없음을 의도적으로 명시, 이전에 할당되었던 값에 대한 참조를 명시적으로 제거

// Symbol : 다른 값과 중복되지 않는 유일무이한 값, 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 값을 만들기 위해사용
let vv2 = Symbol("key");
console.log(typeof key); // symbol
let obj1 = {};
obj1[vv2] = "value1";
console.log(obj1[vv2]); // value1

// Object : 자바스크립트를 이루는 거의 모든 것이 객체

// 연산자 ----------------------------------------------------------------------------------------
// 연산자 : 하나 이상의 표현식을 대상으로 산술,할당,비교,논리,타입,지수 연산 등을 수행해 하나의 값을 만든다
// 피연산자 : 연산의 대상, 값으로 평가될 수 있는 표현식
// 연산자 표현식 : 피연산자와 연산자의 조합
// 연산자 부수 효과 : 할당연산자,증감연산자, delete연산제 는 다른 코드에 영향 준다

// 이항 산술 연산자 : +, -, *, /, %
// 단항 산술 연산자 : ++, --, +, -

// 전위 증가 연산자 - 할당 후 연산
let xx3 = 0;
let vv3 = xx3++;

// 후위 증가 연산자 - 연산 후 할당
let vv4 = ++xx3;
console.log(`vv3 : ${vv3} vv4 : ${vv4}`); // 0, 2

// 할당 연산자 - 우항의 피연산자의 평가 결과를 좌항의 변수에 할당
let vv5;
vv5 = 10;
console.log(vv5); // 10
vv5 += 1;
console.log(vv5); // 11
vv5 -= 2;
console.log(vv5); // 9
vv5 *= 2;
console.log(vv5); // 18
vv5 /= 2;
console.log(vv5); // 9
vv5 %= 2;
console.log(vv5); // 1

// 할당문 : 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다
// vv8 = 0 ----> vv7 = 0 ----> vv6 = 0 즉, vv8=0 자체가 값으로 평가된다
let vv6, vv7, vv8;
vv6 = vv7 = vv8 = 0;
console.log(vv6, vv7, vv8);

// 비교 연산자 : 좌항과 우항의 피연산자를 비교한 후 결과를 불리언으로 반환
// 동등 비교 연산자 : 값만 확인
console.log(1 == "1"); // true

// 일치 비교 연산자 : 값과 타입을 확인
// NaN === NaN 은 자기자신과 일치하지 않는 유일한 값
// !== : === 와 반대
console.log(1 === "1"); // false
console.log(NaN === NaN); // false 임으로 NaN 확인시 Number.isNaN 을 사용

// 대소 비교 : >, < >=, <=

// 삼항 조건 연산자 : 조건식의 평가 결과에 다라 반환값 결정
// if문은 값으로써 할당 불가하나 삼항 조건 연산자는 값으로 평가할 수 있는 표현식인 문
const vv9 = 1 > 0 ? "1은 0보다 크다" : "1은 0 보다 작다";
console.log(vv9); // 1은 0보다 크다

// 논리 연산자
// 단축 평가 : && 는 왼쪽이 true일때 넘어가고, || 는 왼쪽이 false 일 때 넘어간다
console.log((!false && false) || undefined || null || "end");

// 쉼표 연산자
let vv10, vv11;
(vv10 = 1), (vv11 = 2);

// 그룹 연산자
console.log(10 * (1 + 2)); // 30

// typeof 연산자 : 피연산자의 데이터 타입을 문자열로 반환
// string, number, boolean, undefined, symbol, object, function
console.log(typeof null); // object ----> 자바스크립트 버그
console.log(typeof _undefined_); // undefined ----> 선언한 적 없는 식별자는 타입 확인시 undefined

// 지수 연산자 : 이항 연산자중 우선순위 가장 높다
console.log(2 ** 2); // 4

// 연산자 우선 순위
// 1. ()
// 2. new-매개변수존재시,[]-프로퍼티접근, ()-함수호출,?.-옵셔널 체이닝 연산자
// 3. new-매개변수 미존재시
// 4. x++, x--
// 5. !x, +x,-x,++x,--x,typeof,delete
// 6. **
// 7. *, /, %
// 8. +, -
// 9. <, <= , >= , >, in, instanceof
// 10. ==, !=, ===, !==
// 11. !!-null병합 연산자
// 12. &&
// 13. ||
// 14. ? ...:...
// 15. 할당연산자(=,+=,-=,...)
// 16. ,

// 연산자 결합 순서
// 좌항 -> 우항 : +, -, /, %, <, >, <=, >=, &&,||, ., [], (), ??, ?., in, instanceof
// 우항 -> 좌항 : ++, --, 할당연산자, !x, +x, -x, ++x, --x, typeof, delete, ? ...:..., **


// 제어문 ----------------------------------------------------------------------------------------
// 제어문 : 조건따라 코드 블록실행(조건문) 또는 반복실행(반복문) 시 사용
// 블록문 : 0개 이상의 문을 중괄호로 묶은것
// ... 블록문은 문제 종료를 의미하는 자체 종결성을 가짐으로 블록문의 끝에 세미콜론 붙이지 않는다
// 제어문에서 : break 미사용시 다음으로 넘어간다

// 블록문
{
    const de1234 = null;
}

// 함수 선언문
function fun1234() {
    return null;
}

// 조건문(if 문) : 조건식의 평가 결과에 따라 코드 블록의 실행을 결정
if (1 > 0) {
} else if (1 < 0) {
} else {
}

// switch
// 폴스루 : switch 문에서 여러개의 케이스를 하나의 조건으로 사용하는 것
switch ("A") {
    case "A":
        console.log("A");
        break;
    case "B":
        console.log("B");
        break;
    default:
        console.log("default");
        break;
}

// 반복문
for (let i = 0; i < 3; i++) {
    console.log(i);
}
let vv12 = 0;
while (vv12 < 5) {
    vv12++;
    console.log(vv12);
}
let vv13 = 0;
do {
    vv13++;
    if (vv13 > 3) {
        break; // 반복문 또는 switch 문의 코드블록을 탈출
    } else {
        continue; // 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다
    }
} while (true);

// 타입 변환과 단축 평가 ----------------------------------------------------------------------------------------
// 타입 변환 : 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성, 기존 원시 값을 변경하지 않는다
// 불리언 타입이 아닌 값을 Truthy, Falsy로 구분

// 명시적 타입 변환, 타입 캐스팅
console.log(
    '문자열 타입 변환 --------------------------------------------------------------------------',
    '\n',
    String(1), String(NaN), String(Infinity), String(true), // '1', 'NaN', 'Infinity', 'true'
    '\n',
    (1).toString(), (NaN).toString(), (Infinity).toString(), (true).toString(), // '1', 'NaN', 'Infinity', 'true'
    '\n',
    '숫자 타입 변환 --------------------------------------------------------------------------',
    '\n',
    Number('0'), Number(true), // 0,1
    '\n',
    parseInt('0'), parseInt(true), // 0, NaN
    '\n',
    '불리언 타입 변환 --------------------------------------------------------------------------',
    '\n',
    Boolean(''),Boolean(false), Boolean(0), Boolean(NaN), Boolean(null), Boolean(undefined), // 모두 false
    '\n',
    Boolean(' '), Boolean(1), Boolean('qwe'), Boolean([]), Boolean({}), Boolean(Infinity), // 모두 true
    '\n',
);

// 암묵적 타입 변환, 타입 강제 변환, 새로운 타입의 값을 만들어 단 한 번 사용후 버린다
console.log(
    '문자열 타입 변환 --------------------------------------------------------------------------',
    '\n',
    0 + '', // '0'
    '\n',
    NaN + '', // 'NaN'
    '\n',
    Infinity + '', // 'Infinity'
    '\n',
    true + '', // '1'
    '\n',
    null + '', // 'null'
    '\n',
    undefined + '', // 'undefined'
    '\n',
    // (Symbol()) + '', // 타입에러
    '\n',
    ({}) + '', //  [object Object]
    '\n',
    Math + '', //  [object Math]
    '\n',
    [] + '', // ''
    '\n',
    [10, 20] + '', // "10,20"
    '\n',
    (function () {
    }) + '', // function(){}
    '\n',
    Array + '', //  function Array() { [native code] }
    '숫자 타입 변환 --------------------------------------------------------------------------',
    '\n',
    1 - '1', 1 * '1', 1 / 'q', // 1,1,NaN
    '\n',
    +'', +'0', +'1', +'str', // 0,0,1,NaN
    '\n',
    +true, +false, // 1,0
    '\n',
    +null, // 0
    '\n',
    +undefined, // NaN
    '\n',
    // +Symbol(), // 타입에러
    '\n',
    +{}, +[], +[10, 20], +(function () {
    }), // NaN,0,NaN,NaN
    '\n',
    '불리언 타입 변환 --------------------------------------------------------------------------',
    '\n',
    !!' ', !!'qwe', !!12, !!'0', // true, true, true, true
    '\n',
    !!null, !!undefined, !!NaN, !!0, !!'',  // false, false, false, false, false
    '\n',
);

// 단축 평가 : && 는 왼쪽이 true일때 넘어가고, || 는 왼쪽이 false 일 때 넘어간다
console.log((!false && false) || undefined || null || "end");
let vv15 = null;
// vv15가 undefined 또는 null 과 같은 Falsy 값이면 vv15로 평가되고, Truthy 값이라면 vv15.value로 평가된다 ----> 객체의 프로퍼티 확인시 타입 에러 방지
console.log(vv15 && vv15.value);

// 함수 매개변수에 기본값 설정
function fun2(str) {
    str = str || '';
    return str.lenth;
}

function fun3(str = '') {
    return str.lenth;
}

// 옵셔널 체이닝 연산자 : 좌항의 피연산자가 null || undefined 일 경우 undefined반환, 둘 다 아니라면 우항의 프로퍼티 참조를 이어간다
let vv16 = null;
console.log(vv16?.value); // undefined

// null 병합 연산자 : 좌항의 피연산자가 null || undefined 라면 우항의 피연산자 반환, 둘 다 아니라면 좌항의 피연산자 반환
console.log(null ?? 'default_value');
